---
title: Custom request handler
order: 81
---

<Hint mode="warning">
  This page assumes a profound understanding of the library and is{' '}
  <strong>not recommended for beginners</strong>. Before you write a custom API
  wrapper, make sure to understand the underlying concepts first.
</Hint>

You can create a custom Request handler that would be closer to your application's logic, if necessary.

> TODO It'd be nice to have a scenario for a custom request handler. For example, a request handler that processes outgoing traffic only from a specific React component.

## Pre-requisites

Understanding of the following concepts is required before you continue with writing your custom request handler:

- [Request handler](/docs/basics/request-handler)
- [Response resolver](/docs/basics/response-resolver)

## Definition

Request handler must abide the following type definition:

> TODO Add type definition reference

## Declaration

Request handler itself is an object that contains the following properties:

- `mask`
- `predicate`
- `resolver`
- `defineContext`

### Mask

### Predicate

### Resolver

### Define context

The mocking schema you define via calling `setupWorker()`, in fact, keeps a list of such request handler objects and matches all requests against their `predicate` functions. If you take a look at the existing request handlers, you may notice that they are rather functions, not objects:

```js
import { rest } from 'msw'

rest.post('/user', (req, res, ctx) => {})
```

> Under the hood all standard request handlers return the mentioned Object literal. Both are referred to as "request handlers" for simplicity's sake.

Let's take existing request handlers as an inspiration and create a custom handler, which would be a function that accepts an arbitrary list of arguments and returns the request handler Object.

> TODO Add examples

## Examples

### Using request path masking

Request handler can return a mask property that describes a request path mask. If you would like your custom request handler to match requests that satisfy the request path mask, provide that matching logic as a part of the `predicate` function.

> TODO Add examples

### Using custom context

It is possible to provide a custom context to your request handler. To do so, provide an optional `defineContext` property of your request handler. That property must be a function that returns the map of custom context utilities to be provided under the `ctx` argument of the response resolver.

```js
// src/mocks/handlers.js
// TODO
import { halJson } from './transformers/halJson'

const f = () => {
  return {
    defineContext() {
      halJson,
    },
  }
}
```

```js
// src/mocks/index.js
import { setupWorker } from 'msw'
import { f } from './handlers'

const { start } = setupWorker(
  f('???', (req, res, ctx) => {
    // TODO Would be nice to use a meaningful util
    ctx.halJson()
  }),
)
```

Read more on how to create custom context utilities in the respective section of the documentation:

> TODO Add reference to Custom context utiltiy page
